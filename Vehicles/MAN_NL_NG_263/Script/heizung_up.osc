'#######################################################################################################################
'#######################################################################################################################
'                                 H e a t i n g     /     C o o l i n g     S c r i p t
'#######################################################################################################################
'
' Summary
'     Simulates heating and cooling aspects of the vehicle, including the environmental impact on the vehicle's
'     temperature and humidity.
'
'#######################################################################################################################
'
' Dependencies
'     elec (for querying power availability)
'	  engine (for cooling circuit and power availability)
'	  door (for door opening status)
'     cockpit (for window and hatch opening status) 
'
'#######################################################################################################################
'
' Versioning
'     OMSI release:      2.0
'     Script base:       1.0
'     u.p.'s mod:        1.0
'
'#######################################################################################################################
'
' Copyright
'     (c) 20.02.2009    Rüdiger Hülsmann
'     (c) 14.10.2013    Marcel Kuhnt
'     (c) 06.06.2016    Christian Rolle
'     (c) 20.11.2016    u.p.
'
'#######################################################################################################################
'
' Revision History
'
'  1.0
'     u.p.                          *.10.2016    implemented greenhouse-like effect
'      |                                |        A/C temps, v-rates and operational preconditions sanitized and
'                                                    refined (partial credit: M+R, Morphi, for their respective
'                                                    MAN NL/NG, MB O530 heating / cooling scripts)
'      |                                |        implemented humidity management
'      |                                |        reworked heating / cooling panel buttons' LEDs' conditions
'      |                                |        reworked / added missing sound hooks
'      |                                |        added debug constants
'      |                                |        general structural changes and refactoring / extraction of constants
'      |                                |        script formatting and documentation
'      |                                |        max cabin humidity capped to sensible value
'      |                                |        implemented window misting effect and added hooks
'      |                                |        added basic auxiliary heating support (partial credit: M+R, Morphi,
'                                                    for their respective MAN NL/NG and MB O530 heating / cooling
'                                                    scripts)
'      |                                |        cleaned-up varlist and constfile
'      |                            *.11.2016    added basic eco-heating/-cooling, as well as pre-heating/-cooling
'                                                    modes to driver's and passengers' A/C
'      |                                |        the temperature factor of most functions' q-rates is now gradually
'                                                    adjusted, similarly to their v-rates
'      |                                |        greenhouse effect reworked to take losses into account
'
'#######################################################################################################################
'#######################################################################################################################

'------------------
'     Triggers
'------------------

{trigger:cp_heizregler_verteilung_drag}
	(L.S.mouse_X) 150 / (L.L.cockpit_heizregler_verteilung) + 0 max 1 min (S.L.cockpit_heizregler_verteilung)
{end}

{trigger:cp_heizregler_temp_drag}
	(L.S.mouse_X) 150 / (L.L.cockpit_heizregler_temp) + 0 max 1 min (S.L.cockpit_heizregler_temp)
{end}

{trigger:cp_heizregler_geblaese_drag}
	(L.S.mouse_X) 150 / (L.L.cockpit_heizregler_geblaese) + 0 max 1 min (S.L.cockpit_heizregler_geblaese)
{end}

{trigger:taster_fahrerklima}
	1 (S.L.taster_fahrerklima_anim)
	(L.L.cp_taster_fahrerklima) ! (S.L.cp_taster_fahrerklima) (S.L._r15) (M.L.button_sound)
{end}

{trigger:taster_fahrerklima_off}
	0 (S.L.taster_fahrerklima_anim)
{end}

{trigger:taster_frischumluft}
	1 (S.L.taster_frischumluft_anim)
	(L.L.cp_taster_frischumluft) ! (S.L.cp_taster_frischumluft) (S.L._r15) (M.L.button_sound)
{end}

{trigger:taster_frischumluft_off}
	0 (S.L.taster_frischumluft_anim)
{end}

{trigger:taster_klima}
	1 (S.L.taster_klima_anim)
	(L.L.cp_taster_klima) ! (S.L.cp_taster_klima) (S.L._r15) (M.L.button_sound)
{end}

{trigger:taster_klima_off}
	0 (S.L.taster_klima_anim)
{end}

{trigger:taster_zusatzheizung}
	1 (S.L.taster_zusatzheizung_anim)
	(L.L.cp_taster_zusatzheizung) ! (S.L.cp_taster_zusatzheizung) (S.L._r15) (M.L.button_sound)
{end}

{trigger:taster_zusatzheizung_off}
	0 (S.L.taster_zusatzheizung_anim)
{end}

{trigger:taster_heat_or_frost}
	1 (S.L.taster_heat_or_frost_anim)
	(L.L.cp_taster_heat_or_frost) ! (S.L.cp_taster_heat_or_frost) (S.L._r15) (M.L.button_sound)
{end}

{trigger:taster_heat_or_frost_off}
	0 (S.L.taster_heat_or_frost_anim)
{end}

'---------------------
'     Main Macros
'---------------------

' Init
'-----------------------------------------------------------------------------------------------------------------------
{macro:heizung_init}
	(L.S.Weather_Temperature) (S.L.Cabinair_Temp) (S.L.driver_ac_t) (S.L.passenger_ac_t) (S.L.cabin_heater_t)
	(L.S.Weather_AbsHum) (S.L.Cabinair_absHum)
' those are set to a high value initially, to avoid division by 0 (they are used as divisors--see sound macros--prior
'  to actually having been set, during first frame execution)
	(C.L.generic_high_value) (S.L.cabinair_Vrate_driver_ac_max) (S.L.cabinair_Vrate_passenger_ac_max)
		(S.L.cabinair_Vrate_cabinheater_max)
' the following sub-products used by <ghe_impact> are constant, thus only calculated once
	(C.L.ghe_time_max) s0 (C.L.cabinair_Qrate_envir_factor) * (C.L.cabinair_cvm) / (C.L.ghe_env_resistance_factor) *
		(S.L.ghe_env_resistance_const)
	l0 (C.L.cabinair_V) / s0 (C.L.ghe_windowdoor_resistance_factor) * (S.L.ghe_windowdoor_resistance_const)
	l0 (C.L.ghe_ac_resistance_factor) * (S.L.ghe_ac_resistance_const)
{end}

' Frame
'
' First-steps note for modders / integrators: Begin by modifying the number of windows, doors, hatches and cabin
' heaters (<number_of_cabin_heaters> constant), such that they match those of your targeted vehicle. Proceed by
' reconsidering important constants' (e.g., <cabinair_V>, <cabinair_A_xxx>, <cabinair_Vrate_xxx>) values--but
' make sure you do actually understand the relevant segments of the script first though, as there are
' numerous dependencies between, as well as constraints imposed upon and expected to be
' obeyed by many of those constants, and no sanitization is performed by the script.
'-----------------------------------------------------------------------------------------------------------------------
{macro:heizung_frame}
	(L.L.vis_clima) (L.L.vis_clima_h) || (S.L.has_passenger_ac)
	(M.L.cabinair_frame)
	(M.L.actualize_panel_leds)
	(M.L.debug)
{end}

'-----------------------------------
'     <heizung_frame> delegates
'-----------------------------------

' Remnant of the original script. My (i.e., u.p.'s) changes have been, for the most part, moved into separate macros,
' which are called by this one.
'-----------------------------------------------------------------------------------------------------------------------
{macro:cabinair_frame}
	(L.L.Cabinair_Temp) s3
	(L.L.elec_busbar_main) s4
	(L.L.engine_n) (C.L.engine_n_min) > s5
	(L.S.Weather_Temperature) s6
	(L.S.Timegap) (S.L._r9)

' sound-related
	(M.L.actualize_driver_ac_sound)
	(M.L.actualize_passenger_ac_sound)
	(M.L.actualize_ext_ac_sound)
	(M.L.actualize_cabin_heater_sound)
	(M.L.actualize_auxheat_sound)
	
' Berechnung der Luefterbeschleunigung:

' Berechnung der Raten:
	l3 l6 - (C.L.cabinair_Qrate_envir_factor) * (S.L.cabinair_Qrate_envir)

' Direkte Ableitung der Motorwärme in den Fahrgastraum
	(L.L.engine_temperature_envir) l3 - (C.L.cabinair_Qrate_engine_factor) * (S.L.cabinair_Qrate_engine)

' temperature- and status-related
	(M.L.calculate_driver_ac_temps)
	(M.L.actualize_driver_ac_status)
	(M.L.calculate_passenger_ac_temps)
	(M.L.actualize_passenger_ac_status)
	(M.L.actualize_auto_humidity_management_status)
	(M.L.actualize_ac_humidity_management_status)
	(M.L.calculate_cabin_heater_temps)
	(M.L.actualize_cabin_heater_status)
	(M.L.actualize_auxheat_status)
	
' Berechnung der effektiven Gesamt-Luftaustauschfläche:
	(L.L.door_0) (L.L.door_1) (L.L.door_2) (L.L.door_3) (L.L.door_4) (L.L.door_5) + + + + + (C.L.cabinair_A_perdoor) *
		(L.L.cp_klappfenster_1) (L.L.cp_klappfenster_2) (L.L.cp_klappfenster_3) (L.L.klappfenster_4) + + +
                (C.L.cabinair_A_perwindow) * + (C.L.cabinair_A_driverwindow) (L.L.cp_fahrerfenster_pos) * + s0
' hatch contribution varies based on velocity sign, not just state
	(L.L.Dachluke_1_klappe_1) (L.L.Dachluke_2_klappe_1) (L.L.Dachkuke_3_klappe_1) (L.L.Dachluke_4_klappe_1) + + + s1
	(L.L.Dachluke_1_klappe_2) (L.L.Dachluke_2_klappe_2) (L.L.Dachluke_3_klappe_2) (L.L.Dachluke_4_klappe_2) + + + s2
	(L.L.velocity) 0 >
	{if}
		l1 (C.L.cabinair_A_perhatch_zul) * s1
		l2 (C.L.cabinair_A_perhatch_abl) * s2
	{else}
		(L.L.velocity) 0 <
		{if}
			l1 (C.L.cabinair_A_perhatch_abl) * s1
			l2 (C.L.cabinair_A_perhatch_zul) * s2
		{else}
			l1 (C.L.cabinair_A_perhatch_standstill) * s1
			l2 (C.L.cabinair_A_perhatch_standstill) * s2
		{endif}
	{endif}
	l0 l1 + l2 + (S.L.cabinair_A_windowdoor_open)

' Berechnung des Gesamtvolumenstroms in die Außenwelt und umgekehrt (V zählt je Richtung, d.h. insgesamt wird 2*V bewegt)
	(L.L.velocity) 20 / abs (C.L.cabinair_windowdoor_minkmh) + (C.L.cabinair_windowdoor_effectivity) * 3.6 / *
		(S.L.cabinair_Vrate_windowdoor)

' air exchane volume-related
	(M.L.calculate_driver_ac_air_exchange_volumes)
	(M.L.calculate_passenger_ac_air_exchange_volumes)
	(M.L.calculate_cabin_heater_air_exchange_volume)
	
	(C.L.cabinair_V) s1
	
' the following are pre-calculated, as <ghe_impact> depends on them
	l6 l3 - l1 / (L.L.cabinair_Vrate_windowdoor) * (S.L.cabinair_Qrate_windowdoor)
	(L.L.driver_ac_t) l3 - l1 / (L.L.cabinair_Vrate_driver_ac) * (S.L.cabinair_Qrate_driver_ac)
	(L.L.has_passenger_ac)
	{if}
		(L.L.passenger_ac_t) l3 - l1 / (L.L.cabinair_Vrate_passenger_ac) * (S.L.cabinair_Qrate_passenger_ac)
	{endif}
	
' greenhouse update
	(M.L.ghe_impact)
	
	(L.L.Cabinair_Temp) s0
	(C.L.cabinair_V) s1
	(L.L._r9) s2

' cabin temperature update
' Berechnung der Temperaturrate durch Motor und Abstrahlung an die Umwelt...
	(L.L.cabinair_Qrate_engine) (L.L.cabinair_Qrate_envir) - (C.L.cabinair_cvm) /
' ...and due to greenhouse effect...
		(L.L.cabinair_Qrate_ghe_plus_losses) +
' ...und Temperaturrate durch Passagiere...
		(C.L.cabinair_T_passenger) l0 - l1 / (C.L.cabinair_Vrate_passenger) * (L.L.humans_count) * +
' ...und dieser durch die Volumenströme durch Fenster und Türen:
		(L.L.cabinair_Qrate_windowdoor) +
' ...und des Frontheizgerätes...
		(L.L.cabinair_Qrate_driver_ac) +
' ...und der Raumheizgeräte...
		(L.L.cabin_heater_t) l0 - l1 / (L.L.cabinair_Vrate_cabinheater) * + s3
' ...und der Klimaanlage...
	(L.L.has_passenger_ac)
	{if}
		l3 (L.L.cabinair_Qrate_passenger_ac) + s3
	{endif}
' ...aufintegrieren:
	l3 l2 * l0 + (S.L.Cabinair_Temp) s0

' Berechnung der Motorkühlrate durch die Wärmetauscher in den Heizgeräten:
	(L.L.driver_ac_t) l0 - 0 max l1 / (L.L.cabinair_Vrate_driver_ac) * (L.L.cabin_heater_t) l0 max l0 - l1 /
		(L.L.cabinair_Vrate_cabinheater) * + (C.L.cabinair_cvm) * 8 *
		(S.L.cabinair_Qrate_engine_fanheatcooling)

	(L.L.Cabinair_absHum) s3
	(L.S.Weather_AbsHum) s7
	
' cabin humidity update
' Berechnung der Feuchtigkeitsrate durch Volströme mit den Passagieren:
	(C.L.cabinair_absHum_passenger) l3 - l1 / (C.L.cabinair_Vrate_passenger) * (L.L.humans_count) *
' Berechnung der Feuchtigkeitsrate durch Volumenströme mit der Außenwelt:
		l7 l3 - l1 / (L.L.cabinair_Vrate_windowdoor) * +
' Berechnung der Feuchtigkeitsrate durch Frontheizgerät
		l7 l3 - l1 / (L.L.cabinair_Vrate_driver_ac_humidity) * + (S.L._r9)
' ...und durch Klimaanlage
	(L.L.has_passenger_ac)
	{if}
		(L.L._r9) l7 l3 - l1 / (L.L.cabinair_Vrate_passenger_ac_humidity) * + (S.L._r9)
	{endif}
	(L.L._r9) l2 * l3 + (S.L._r9)
' estimate saturation humidity for cabin temp
	l0 (F.L.saturation_humidity_f_temp) (S.L._r14)
' hack to prevent unrealistic skyrocketing of cabin humidity; this still fails under very low temps (t < ~ -45 oC)
'  though, as my saturation humidities severely diverge from OMSI's respective ones within that range
	(L.L._r9) (L.L._r14) (C.L.cabin_rel_humidity_max) * min (S.L._r9)
' estimate new relative humidity
	(L.L._r9) (L.L._r14) / (C.L.cabin_rel_humidity_max) min (S.L._r8)
' absolute humidity reduction due to A/C-induced dehumidification, if relative humidity above reasonable limit
	(L.L.ac_humidity_management_active) (L.L._r8)
		(C.L.dehumidification_cabin_rel_humidity_min) > &&
	{if}
		1 (C.L.dehumidification_effectiveness) * l2 * l0 (F.L.humidity_management_effectiveness_f_temp) * - (L.L._r9) *
			(S.L._r9)
	{else}
' absolute humidity increase due to A/C-induced humidification, if relative humidity below reasonable limit
		(L.L.ac_humidity_management_active) (L.L._r8) (C.L.humidification_cabin_rel_humidity_max) < &&
		{if}
			1 (L.L._r9) (C.L.humidification_effectiveness) * l2 * l0 (F.L.humidity_management_effectiveness_f_temp) * +
				(L.L._r9) * (S.L._r9)
		{endif}
	{endif}
' assign results
	(L.L._r9) (S.L.Cabinair_absHum)
	(L.L.Cabinair_relHum) (S.L._r8)

' window misting degree update
' disregard these macros if you're the kind of person who values scientific accuracy, for your eyes _will bleed_ otherwise
	(M.L.calculate_cabin_window_int_misting_degree)
	(M.L.calculate_cabin_window_ext_misting_degree)
	
' engine temperature update due to auxheat; this bit has been shamelessly copied off of Morphi's script
	(L.L.auxheat_active) (C.L.heizung_Qrate_auxheat) (L.L.cabinair_Qrate_envir) - (C.L.engine_cvm_engine) / l2 * *
		(L.L.engine_temperature) + (S.L.engine_temperature)
{end}

' Controls the heating / cooling panel's buttons' LEDs.
' Blinking signals that the corresponding function is unavailable, is in the process of starting up, or, in the case of
' <cp_taster_heat_or_frost>, has been automatically initiated.
'-----------------------------------------------------------------------------------------------------------------------
{macro:actualize_panel_leds}
	(L.L.elec_busbar_main)
	{if}
		(L.L.global_led_target) s0
		(L.L.global_led_timer) (L.S.Timegap) + s1 1 >=
		{if}
			l0 ! s0
			0 s1
		{endif}
		l0 (S.L.global_led_target)
		l1 (S.L.global_led_timer)
		(L.L.cp_taster_fahrerklima) (L.L.driver_ac_running) 0 > s1 l0 l1 ! && || && (S.L.cp_taster_fahrerklima_led)
		(L.L.cp_taster_klima) (L.L.passenger_ac_running) 0 > s1 l0 l1 ! && || && (S.L.cp_taster_klima_led)
		(L.L.cp_taster_frischumluft) (S.L.cp_taster_frischumluft_led)
		(L.L.cp_taster_zusatzheizung) (L.L.auxheat_active) s1 l0 l1 ! && || && (S.L.cp_taster_zusatzheizung_led)
		(L.L.cp_taster_heat_or_frost) s1
		(L.L.ac_humidity_management_active) s2
		(L.L.cabin_heater_dehumidification_active) s3
' constantly on if button pushed and A/C humidity management or cabin heater-based dehumidification active
' blinking if button pushed and both A/C humidity management and cabin heater-based dehumidification unavailable, or
'  engine off, or button not pushed and A/C humidity management active (implying automatic mode)
' see also the <actualize_auto_humidity_management_status>, <actualize_ac_humidity_management_status> and
'  <actualize_cabin_heater_status> macros
		l1 l2 l3 || && l0 l1 (L.L.engine_n) (C.L.engine_n_min) <= l2 ! l3 ! && || && l1 ! l2 && || && ||
			(S.L.cp_taster_heat_or_frost_led)
	{else}
		0 (S.L.cp_taster_fahrerklima_led) (S.L.cp_taster_klima_led) (S.L.cp_taster_frischumluft_led)
			(S.L.cp_taster_zusatzheizung_led) (S.L.cp_taster_heat_or_frost_led)
			(S.L.global_led_timer) (S.L.global_led_target)
	{endif}
{end}

' Assigns logical predefined variable groups' values to the debugging variables (which are only displayed in "-debug",
' of course).
'
' Modify <debug_var_group> in <.\heizung_constfile_up.txt> to use this.
'
' Note: Unless real-time updates of the values are desired, saving the current situation and viewing
' <<OMSI>\maps\<map_name>\laststn.osn> in a text editor is typically more convenient, as it provides a snapshot of
' _all_ of the vehicle's variables' values.
'-----------------------------------------------------------------------------------------------------------------------
{macro:debug}
	(C.L.debug_var_group) s0
	{if}
		(L.L.Cabinair_Temp) s1
		(C.L._debug_reg_unused_placeholder) (S.L._r8)
		l0 (C.L._debug_driver_ac_temps_and_v_rates_group_id) =
		{if}
			(L.L.driver_ac_t_target) s2
			(L.L.driver_ac_t) s3
			(L.L.cabinair_Vrate_driver_ac_target) s4
			(L.L.cabinair_Vrate_driver_ac) s5
			(L.L.driver_ac_running) s6
		{else}
			l0 (C.L._debug_passenger_ac_temps_and_v_rates_group_id) =
			{if}
				(L.L.passenger_ac_t_target) s2
				(L.L.passenger_ac_t) s3
				(L.L.cabinair_Vrate_passenger_ac_target) s4
				(L.L.cabinair_Vrate_passenger_ac) s5
				(L.L.passenger_ac_running) s6
			{else}
				l0 (C.L._debug_cabin_heater_temps_and_v_rates_group_id) =
				{if}
					(L.L.cabin_heater_t_target) s2
					(L.L.cabin_heater_t) s3
					(L.L.cabinair_Vrate_cabinheater_target) s4
					(L.L.cabinair_Vrate_cabinheater) s5
					(L.L.cabin_heaters_running) s6
				{else}
					l0 (C.L._debug_driver_ac_sounds_group_id) =
					{if}
						(L.L.driver_ac_fan_sound_vol_target) s2
						(L.L.driver_ac_fan_sound_vol) s3
						(L.L.driver_ac_int_sound_vol_target) s4
						(L.L.driver_ac_int_sound_vol) s5
						(L.L._r8) s6
					{else}
						l0 (C.L._debug_passenger_ac_sounds_group_id) =
						{if}
							(L.L.passenger_ac_fan_sound_vol_target) s2
							(L.L.passenger_ac_fan_sound_vol) s3
							(L.L.passenger_ac_int_sound_vol_target) s4
							(L.L.passenger_ac_int_sound_vol) s5
							(L.L._r8) s6
						{else}
							l0 (C.L._debug_cabin_heater_sound_group_id) =
							{if}
								(L.L.cabin_heaters_sound_vol_target) s2
								(L.L.cabin_heaters_sound_vol) s3
								(L.L._r8) s4 s5 s6
							{else}
								l0 (C.L._debug_ext_ac_sound_group_id) =
								{if}
									(L.L.ac_ext_sound_vol_target) s2
									(L.L.ac_ext_sound_vol) s3
									(L.L._r8) s4 s5 s6
								{else}
									l0 (C.L._debug_humidity_rates_group_id) =
									{if}
										(L.L.Cabinair_relHum) s2
										(L.L.cabinair_Vrate_driver_ac_humidity) s3
										(L.L.cabinair_Vrate_passenger_ac_humidity) s4
										(L.L._r8) s5 s6
									{else}
										l0 (C.L._debug_window_misting_group_id) =
										{if}
											(L.L.env_dew_point) s2
											(L.L.cabin_dew_point) s3
											(L.L.cabin_window_int_misting) s4
											(L.L.cabin_window_ext_misting) s5
											(L.L._r8) s6
										{else}
											l0 (C.L._debug_ghe_group_id) =
											{if}
												(L.L.cabinair_Qrate_ghe_plus_losses) s2
												(L.L.cabinair_Qrate_ghe) s3
												(L.L._r8) s4 s5 s6
											{else}
												(L.L._r8) s7
											{endif}
										{endif}
									{endif}
								{endif}
							{endif}
						{endif}
					{endif}
				{endif}
			{endif}
		{endif}
		l7 (L.L._r8) = !
		{if}
			l1 (L.L._r8) s7 = !
			{if}
				l1 (S.L.debug_0)
			{endif}
			l2 l7 = !
			{if}
				l2 (S.L.debug_1)
			{endif}
			l3 l7 = !
			{if}
				l3 (S.L.debug_2)
			{endif}
			l4 l7 = !
			{if}
				l4 (S.L.debug_3)
			{endif}
			l5 l7 = !
			{if}
				l5 (S.L.debug_4)
			{endif}
			l6 l7 = !
			{if}
				l6 (S.L.debug_5)
			{endif}
		{endif}
	{endif}
{end}

'------------------------------------
'     <cabinair_frame> delegates
'------------------------------------

' Updates the driver's A/C's (fan-/A/C-specific, interior) sound volume.
'-----------------------------------------------------------------------------------------------------------------------
{macro:actualize_driver_ac_sound}
' <r4> = <elec_busbar_main>
' we check for electrics, since we don't want to hear the fan when they're off (the v-rate might, even then, be non-null)
	l4 (L.L.cabinair_Vrate_driver_ac) s0 && (L.L.cockpit_heizregler_geblaese) &&
	{if}
		l0 (L.L.cabinair_Vrate_driver_ac_max) / s0
	{else}
		0 s0
	{endif}
' fan-specific
	l0 (S.L.driver_ac_fan_sound_vol_target)
' gradual update
	(L.L.driver_ac_fan_sound_vol) (S.L._r10) l0 (S.L._r11) (C.L.driver_ac_fan_sound_update_rate) (S.L._r12)
		(M.L.from_r10_to_r11_at_r12) (L.L._r10) (S.L.driver_ac_fan_sound_vol) s0
' A/C-specific (eco and pre-heating/-cooling modes don't count)
	(L.L.driver_ac_running) 1 = (L.L.driver_ac_fan_sound_vol_target) (C.L.driver_ac_int_sound_min) max *
		(S.L.driver_ac_int_sound_vol_target) s0
' gradual update
	(L.L.driver_ac_int_sound_vol) (S.L._r10) l0 (S.L._r11) (C.L.driver_ac_int_sound_update_rate) (S.L._r12)
		(M.L.from_r10_to_r11_at_r12) (L.L._r10) (S.L.driver_ac_int_sound_vol)
{end}

' Updates the passengers' A/C's (fan-/A/C-specific, interior) sound volume.
'-----------------------------------------------------------------------------------------------------------------------
{macro:actualize_passenger_ac_sound}
	(L.L.cabinair_Vrate_passenger_ac) s0
	{if}
		l0 (L.L.cabinair_Vrate_passenger_ac_max) / s0
	{else}
		0 s0
	{endif}
' fan-specific
	l0 (S.L.passenger_ac_fan_sound_vol_target)
' gradual update
	(L.L.passenger_ac_fan_sound_vol) (S.L._r10) l0 (S.L._r11) (C.L.passenger_ac_fan_sound_update_rate) (S.L._r12)
		(M.L.from_r10_to_r11_at_r12) (L.L._r10) (S.L.passenger_ac_fan_sound_vol) s0
' A/C-specific (eco and pre-heating/-cooling modes don't count)
	l0 (L.L.passenger_ac_running) 1 = && (L.L.ac_humidity_management_active)
		(C.L.ac_humidity_management_passenger_ac_int_sound_contribution) * || (S.L.passenger_ac_int_sound_vol_target)
		s0
' gradual update
	(L.L.passenger_ac_int_sound_vol) (S.L._r10) l0 (S.L._r11) (C.L.passenger_ac_int_sound_update_rate) (S.L._r12)
		(M.L.from_r10_to_r11_at_r12) (L.L._r10) (S.L.passenger_ac_int_sound_vol)
{end}

' Updates the exterior (i.e., the visible--unless deactivated through repaint var, or at runtime--roof-mounted)
' A/C unit's sound volume.
'-----------------------------------------------------------------------------------------------------------------------
{macro:actualize_ext_ac_sound}
' eco mode doesn't count; normal and pre-heating/-cooling modes both do, however
	(L.L.driver_ac_running) abs 1 = (C.L.driver_ac_ac_ext_sound_contribution) * (L.L.passenger_ac_running) abs 1 =
		(L.L.ac_humidity_management_active) || (C.L.passenger_ac_ac_ext_sound_contribution) * + (L.L.has_passenger_ac)
		* (S.L.ac_ext_sound_vol_target) s0
' gradual update
	(L.L.ac_ext_sound_vol) (S.L._r10) l0 (S.L._r11) (C.L.ac_ext_sound_update_rate) (S.L._r12)
		(M.L.from_r10_to_r11_at_r12) (L.L._r10) (S.L.ac_ext_sound_vol)
{end}

' Updates the cabin heaters' sound volume.
'-----------------------------------------------------------------------------------------------------------------------
{macro:actualize_cabin_heater_sound}
	(L.L.cabin_heaters_running)
	{if}
		(L.L.cabinair_Vrate_cabinheater) (L.L.cabinair_Vrate_cabinheater_max) / s0
	{else}
		0 s0
	{endif}
	l0 (S.L.cabin_heaters_sound_vol_target)
' gradual update	
	(L.L.cabin_heaters_sound_vol) (S.L._r10) l0 (S.L._r11) (C.L.cabin_heater_sound_update_rate) (S.L._r12)
		(M.L.from_r10_to_r11_at_r12) (L.L._r10) (S.L.cabin_heaters_sound_vol)
{end}

' Updates the auxiliary heating's sound volume.
'-----------------------------------------------------------------------------------------------------------------------
{macro:actualize_auxheat_sound}
	(L.L.auxheat_active) (S.L.auxheat_sound_vol_target) s0
' gradual update
	(L.L.auxheat_sound_vol) (S.L._r10) l0 (S.L._r11) (C.L.auxheat_sound_update_rate) (S.L._r12)
		(M.L.from_r10_to_r11_at_r12) (L.L._r10) (S.L.auxheat_sound_vol)
{end}

'-----------------------------------------------------------------------------------------------------------------------
' Short example to help you understand the somewhat convoluted <calculate_xxx_ac_temps> and <actualize_xxx_ac_status>
' macros:
'
' Say that it's reasonably warm and it is decided to cool the vehicle through either of the A/C-based functions. The
' following illustrate what happens once the corresponding button has been pushed. Note that sufficient power supply
' and constant environmental conditions are assumed at all times.
'
' 1. <calculate_xxx_ac_temps> (M1) gets invoked, acknowledges the "on" state of the button, performs various checks
'   and, assuming they all pass, assigns some temp lower than <Cabinair_Temp> to <xxx_ac_t_preview> (V1), as well
'   as the value 1 to <xxx_ac_t_running_target> (V2).
' 2. <actualize_xxx_ac_status> (M2) gets invoked, acknowledges the value of V2 set above and initializes a delay timer,
'   based on V1, among other factors, representing the A/C unit's "inertia" to react to an activation event.
' 3. For a number of subsequent frames, nothing noteworthy occurs, except for M2's incrementation of its aforementioned
'   timer's value.
' 4. Once its timer has expired, M2 sets <xxx_ac_running> (V3) to 1 or -1. The <ac_t_comfortable> (M3) macro's
'   documentation explains the difference. For the sake of completeness, assume it's -1.
' 5. Upon its invocation during executing of the next frame, M1 acknowledges V3's value, assigns V1 to
'   <xxx_ac_t_target> (V4) and begins decrementing <xxx_ac_t> (V5) towards V4.
' 6. Again, nothing worth mentioning changes for a number of frames, except for M1's decrementation of V5.
' 7. Once M3 determines (on M2's behalf) that V5 is low enough, M2 (signalled to do so by M3's outcome) sets V3 to 1,
'   meaning that the A/C is now "officially" active. From that point on--which might lie several minutes ahead of the
'   first step in time--does, at long last, actual cooling of the cabin begin (via
'   <calculate_driver_ac_air_exchange_volumes>, which falls outside of this
'   discussion's scope).
'-----------------------------------------------------------------------------------------------------------------------

' Determines the driver's A/C's output temperature.
'-----------------------------------------------------------------------------------------------------------------------
{macro:calculate_driver_ac_temps}
' A/C-based heating / cooling requested
' <r4> = <elec_busbar_main>
' <r5> = <engine_n> > <engine_n_min>
	l4 l5 && (L.L.cp_taster_fahrerklima) &&
	{if}
' first output temp estimation
		(C.L.driver_ac_min_selectable_t) (C.L.driver_ac_min_max_selectable_t_interval) (L.L.cockpit_heizregler_temp) *
			+ s0
' sanity-check
		(M.L.ac_available) (L.L._r8)
		{if}
' pass; A/C is to be activated
' check if eco mode applies
			(M.L.ac_eco_mode_available) (L.L._r8)
			{if}
' A/C is to be activated in eco mode; but still, don't allow the actual output temp to be cooler than <r0>, when
'  cooling, or warmer than <r0>, when heating
				l3 (C.L.ac_cooling_cabin_t_min) >
				{if}
					l6 l0 max s2
				{else}
					l6 l0 min s2
				{endif}
' indicate that <actualize_driver_ac_status> may begin, if it hasn't already, attempting to start the A/C
				2 s1
			{else}
' A/C is to be activated in normal mode
' increase or decrease actual respective cooling or heating output temp, based on its difference from current cabin or
'  env temp, depending on whether recirculation or fresh mode is respectively in effect
' <r3> = <Cabinair_Temp>
				l3 (C.L.ac_cooling_cabin_t_min) >
				{if}
					(C.L.ac_cooling_loss_per_degree) s7
				{else}
					(C.L.ac_heating_loss_per_degree) s7
				{endif}
				(L.L.cp_taster_frischumluft)
				{if}
					l3 l0 - (S.L._r8)
				{else}
					l6 l0 - (S.L._r8)
				{endif}
				l0 (L.L._r8) l7 * + s2
' don't allow the A/C to start when the cabin heaters are running and it is very cold; the A/C will be unable to
'  "compete" with the cabin heaters and severely reduce their effectiveness otherwise
				(L.L.cabin_heaters_running) l2 (C.L.ac_heating_cabin_t_max) <= &&
				{if}
					0 s1
					l3 s2
				{else}
' indicate that <actualize_driver_ac_status> may begin, if it hasn't already, attempting to start the A/C
					1 s1
				{endif}
			{endif}
' only update the output temp if <actualize_driver_ac_status> has actually activated the A/C; else wait, using the
'  current cabin temperature instead
			(L.L.driver_ac_running)
			{if}
				l2 s0
			{else}
				l3 s0
			{endif}
		{else}
' fail; A/C will be / stay deactivated
			l3 s0 s2
			0 s1
		{endif}
	{else}
' environment-/engine-based heating / cooling; A/C will be / stay deactivated
		0 s1
		(L.L.cp_taster_frischumluft)
		{if}
' mix cabin-recirculated with engine-heated air
			l3 s0
		{else}
' mix fresh with engine-heated air
			l6 s0
		{endif}
' purpose of constants:
' - <fan_heater_target_t_engine_factor> reduces the engine-heated air's temperature
'  (we don't want 80+ -degree air entering our cabin)
' - <fan_heater_cabin_t_increase_max> acts as the overall threshold
		l0 (L.L.engine_temperature) l0 max l0 - (L.L.cockpit_heizregler_temp) * (C.L.fan_heater_target_t_engine_factor)
			* + l0 (C.L.fan_heater_cabin_t_increase_max) + min s0 s2
	{endif}
	l0 (S.L.driver_ac_t_target)
	l1 (S.L.driver_ac_running_target)
	l2 (S.L.driver_ac_t_target_preview)
' gradual update
	(M.L.actualize_driver_ac_output_air_temp)
{end}

' Actually (de-)activates the driver's A/C.
'-----------------------------------------------------------------------------------------------------------------------
{macro:actualize_driver_ac_status}
' this is determined via <calculate_driver_ac_temps>
	(L.L.driver_ac_running_target) s2
	{if}
' activation branch
' new start condition (cached for duplication reduction)
' <ac_cooldown_threshold_t_diff> contributes to an "anti-repeat" condition, so as to prevent on-off loops
' <r3> = <Cabinair_Temp>
		l3 (C.L.ac_heating_cabin_t_max) (C.L.ac_cooldown_threshold_t_diff) s0 - < l3 (C.L.ac_cooling_cabin_t_min) l0 + >
			|| s7
		(L.L.driver_ac_running) 1 = (L.L.passenger_ac_running) 1 = (L.L.ac_humidity_management_active) || l7 && ||
		{if}
' no delay if driver's A/C some other A/C-based function already active; activate (/ resume)
			0 s0
			-1 s1
		{else}
' start anew
			(L.L.driver_ac_start_stop_delay) s1 -1 =
			{if}
				(C.L.driver_ac_start_delay_additional_max) random (C.L.driver_ac_start_delay_min) + s1
				l2 1 =
				{if}
' increase delay based on env-to-target difference (doesn't apply to eco mode)
					l6 (L.L.driver_ac_t_target_preview) - abs (C.L.driver_ac_start_delay_env_factor) * l1 + s1
				{endif}
			{endif}
' <_r9> = <Timegap>
			(L.L.driver_ac_start_stop_timer) (L.L._r9) + s0 l1 > l7 &&
			{if}
' actually activate
				0 s0
				-1 s1
			{else}
' no change; inactive and stays inactive
				(L.L.driver_ac_running) s2
			{endif}
		{endif}
	{else}
' deactivation branch
		(L.L.driver_ac_running) s2
		{if}
			(L.L.driver_ac_start_stop_delay) s1 -1 =
			{if}
				(C.L.driver_ac_stop_delay_additional_max) random (C.L.driver_ac_stop_delay_min) + s1
			{endif}
' deactivation condition: either direct and _delayed_ (timer-based, when e.g. power is lost or function is switched off
'  by user), or indirect and _instant_ (target cabin temp achieved)
			(L.L.driver_ac_start_stop_timer) (L.L._r9) + s0 l1 > l4 l5 && l3 (C.L.ac_heating_cabin_t_max) >= &&
				l3 (C.L.ac_cooling_cabin_t_min) <= && ||
			{if}
' actually deactivate
				0 s0 s2
				-1 s1
' else: no change; active and stays active
			{endif}
		{else}
' no change; inactive and stays inactive
			0 s0
			-1 s1
		{endif}
	{endif}
	l0 (S.L.driver_ac_start_stop_timer)
	l1 (S.L.driver_ac_start_stop_delay)
' prevent <driver_ac_running> from becoming 1 iff <driver_ac_t> not (yet) in comfort levels
	(L.L.driver_ac_t) s0 (L.L.driver_ac_t_target_preview) s1 (M.L.ac_t_comfortable) l2 (S.L.driver_ac_running)
{end}

' Determines the passengers' A/C's output temperature.
'-----------------------------------------------------------------------------------------------------------------------
{macro:calculate_passenger_ac_temps}
	(L.L.has_passenger_ac)
	{if}
' <r4> = <elec_busbar_main>
' <r5> = <engine_n> > <engine_n_min>
		l4 l5 && (L.L.cp_taster_klima) &&
		{if}
' <r3> = <Cabinair_Temp>
' automatic temperature selection--driver has no influence
			l3 (C.L.ac_cooling_cabin_t_min) >
			{if}
				(C.L.ac_cooling_output_t_min) s0
			{else}
				(C.L.ac_heating_output_t_max) s0
			{endif}
' sanity-check
			(M.L.ac_available) (L.L._r8)
			{if}
' pass; A/C is to be activated
' check if eco mode applies
				(M.L.ac_eco_mode_available) (L.L._r8)
				{if}
' A/C is to be activated in eco mode; but still, don't allow the actual output temp to be cooler than <r0>, when
'  cooling, or warmer than <r0>, when heating
				l3 (C.L.ac_cooling_cabin_t_min) >
				{if}
					l6 l0 max s2
				{else}
					l6 l0 min s2
				{endif}
' indicate that <actualize_passenger_ac_status> may begin, if it hasn't already, attempting to start the A/C
					2 s1
				{else}
' A/C is to be activated in normal mode
' increase or decrease actual respective cooling or heating output temp, based on its difference from current cabin or
'  env temp, depending on whether recirculation or fresh mode is respectively in effect
					l0 (C.L.ac_cooling_cabin_t_min) >
					{if}
						(C.L.ac_cooling_loss_per_degree) s7
					{else}
						(C.L.ac_heating_loss_per_degree) s7
					{endif}
					(L.L.cp_taster_frischumluft)
					{if}
						l3 l0 - (S.L._r8)
					{else}
						l6 l0 - (S.L._r8)
					{endif}
					l0 (L.L._r8) l7 * + s2
' don't allow the A/C to start when the cabin heaters are running and it is very cold; the A/C will be unable to
'  "compete" with the cabin heaters and severely reduce their effectiveness otherwise
					(L.L.cabin_heaters_running) l2 (C.L.ac_heating_cabin_t_max) <= &&
					{if}
						0 s1
						l3 s2
					{else}
' indicate that <actualize_passenger_ac_status> may begin, if it hasn't already, attempting to start the A/C
						1 s1
					{endif}
				{endif}
' only update the output temp if <actualize_passenger_ac_status> has actually activated the A/C; else wait, using the
'  current cabin temperature instead
				(L.L.passenger_ac_running)
				{if}
					l2 s0
				{else}
' wait, using the current cabin temperature instead
					l3 s0
				{endif}
			{else}
' fail; A/C will be / stay deactivated
				l3 s0 s2
				0 s1
			{endif}
		{else}
' no power; stay / become deactivated
			l3 s0 s2
			0 s1
		{endif}
	{else}
' no passenger A/C unit available at all; stay / become deactivated
		l3 s0 s2
		0 s1
	{endif}
	l0 (S.L.passenger_ac_t_target)
	l1 (S.L.passenger_ac_running_target)
	l2 (S.L.passenger_ac_t_target_preview)
' gradual update
	(M.L.actualize_passenger_ac_output_air_temp)
{end}

' Actually (de-)activates the passengers' A/C.
'-----------------------------------------------------------------------------------------------------------------------
{macro:actualize_passenger_ac_status}
' this is determined via <calculate_passenger_ac_temps>
	(L.L.passenger_ac_running_target) s2
	{if}
' activation branch
' new start condition (cached for duplication reduction)
' <ac_cooldown_threshold_t_diff> contributes to an "anti-repeat" condition, so as to prevent on-off loops
' <r3> = <Cabinair_Temp>
		l3 (C.L.ac_heating_cabin_t_max) (C.L.ac_cooldown_threshold_t_diff) s0 - < l3 (C.L.ac_cooling_cabin_t_min) l0 + >
			|| s7
		(L.L.passenger_ac_running) 1 = (L.L.driver_ac_running) 1 = (L.L.ac_humidity_management_active) || l7 && ||
		{if}
' no delay if passengers' A/C or some other A/C-based function already active; activate (/ resume)
			0 s0
			-1 s1
		{else}
' start anew
			(L.L.passenger_ac_start_stop_delay) s1 -1 =
			{if}
				(C.L.passenger_ac_start_delay_additional_max) random (C.L.passenger_ac_start_delay_min) + s1
				l2 1 =
				{if}
' increase delay based on env-to-target difference (doesn't apply to eco mode)
					l6 (L.L.passenger_ac_t_target_preview) - abs (C.L.passenger_ac_start_delay_env_factor) * l1 + s1
				{endif}
			{endif}
' <_r9> = <Timegap>
			(L.L.passenger_ac_start_stop_timer) (L.L._r9) + s0 l1 > l7 &&
			{if}
' actually activate
				0 s0
				-1 s1
			{else}
' no change; inactive and stays inactive
				(L.L.passenger_ac_running) s2
			{endif}
		{endif}
	{else}
' deactivation branch
		(L.L.passenger_ac_running) s2
		{if}
			(L.L.passenger_ac_start_stop_delay) s1 -1 =
			{if}
				(C.L.passenger_ac_stop_delay_additional_max) random (C.L.passenger_ac_stop_delay_min) + s1
			{endif}
' deactivation condition: either direct and _delayed_ (timer-based, when e.g. power is lost or function is switched off
'  by user), or indirect and _instant_ (target cabin temp achieved)
			(L.L.passenger_ac_start_stop_timer) (L.L._r9) + s0 l1 > l4 l5 && l3 (C.L.ac_heating_cabin_t_max) >= &&
				l3 (C.L.ac_cooling_cabin_t_min) <= && ||
			{if}
' actually deactivate
				0 s0 s2
				-1 s1
' else: no change; active and stays active
			{endif}
		{else}
' no change; inactive and stays inactive
			0 s0
			-1 s1
		{endif}
	{endif}
	l0 (S.L.passenger_ac_start_stop_timer)
	l1 (S.L.passenger_ac_start_stop_delay)
' prevent <passenger_ac_running> from becoming 1 iff <passenger_ac_t> not (yet) in comfort levels
	(L.L.passenger_ac_t) s0 (L.L.passenger_ac_t_target_preview) s1 (M.L.ac_t_comfortable) l2 (S.L.passenger_ac_running)
{end}

' (De-)activates the automatic humidity management function, which is, in turn, controlled by the A/C-based humidity
' management function, the status of which is controlled through <actualize_ac_humidity_management_status>.
' Auto-(de)humidification gets activated when a) the vehicle has passenger air-conditioning _and_ b) either or both of
' the driver's and/or passengers' A/C functions have been requested (they need _not_ necessarily be in a _running_
' state), _and_ c) power is sufficient (implying both engine and electrics), _and_ d) the cabin's humidity
' level exceeds <auto_humidity_management_dehumidification_start_rel_cabin_humidity_max>, or is less than
' <auto_humidity_management_humidification_start_rel_cabin_humidity_min>.
'
' When auto humidity management is active and <cp_taster_heat_or_frost> has not been pushed, the corresponding button's
' LED blinks.
'
' Note: This macro doesn't employ the timer-based structure of the previous similar ones, because, as already mentioned,
' there's a separate macro--<actualize_ac_humidity_management_status>--in place for that purpose.
'-----------------------------------------------------------------------------------------------------------------------
{macro:actualize_auto_humidity_management_status}
	(L.L.Cabinair_relHum) s0
' <r4> = <elec_busbar_main>
' <r5> = <engine_n> > <engine_n_min>
	l4 l5 &&
	{if}
		(L.L.has_passenger_ac) (L.L.cp_taster_fahrerklima) (L.L.cp_taster_klima) || && s1
			l0 (C.L.auto_humidity_management_dehumidification_start_rel_cabin_humidity_max) >
			l0 (C.L.auto_humidity_management_humidification_start_rel_cabin_humidity_min) <
			|| &&
		{if}
			1 s7
		{else}
			l1 ! (L.L.auto_humidity_management) s7
				l0 (C.L.auto_humidity_management_dehumidification_stop_rel_cabin_humidity_min) <=
				l0 (C.L.auto_humidity_management_humidification_stop_rel_cabin_humidity_max) >=
				&& && ||
			{if}
				0 s7
			{endif}
		{endif}
	{else}
		0 s7
	{endif}
	l7 (S.L.auto_humidity_management)
{end}

' Controls A/C-based (de)humidification, which comprises both the automatic (see
' <actualize_auto_dehumidification_status>) and the "manual" humidity management
' (triggered by <cp_taster_heat_or_frost>) function. Both in-/de-crement
' humidity at the exact same rate, but their min/max thresholds differ.
'-----------------------------------------------------------------------------------------------------------------------
{macro:actualize_ac_humidity_management_status}
' <r3> = <Cabinair_Temp>
' <r4> = <elec_busbar_main>
' <r5> = <engine_n> > <engine_n_min>
' <r6> = <Weather_Temperature>
	(L.L.Cabinair_relHum) s7
	l4 l5 && l6 (C.L.ac_env_t_min) s0 > && l6 (C.L.ac_env_t_max) s1 < && l3 l0 > && l3 l1 < && (L.L.has_passenger_ac)
		&& (L.L.auto_humidity_management) (L.L.cp_taster_heat_or_frost) || && l7
		(C.L.dehumidification_cabin_rel_humidity_min) >	l7 (C.L.humidification_cabin_rel_humidity_max) < || &&
	{if}
' activation branch
' new start condition (cached for duplication reduction)
' <humidity_management_cooldown_threshold_humidity_diff> contributes to an "anti-repeat" condition, so as to prevent on-off loops
		l7 (C.L.dehumidification_cabin_rel_humidity_min)
			(C.L.humidity_management_cooldown_threshold_humidity_diff) + >
			(L.L.Cabinair_relHum) (C.L.humidification_cabin_rel_humidity_max)
			(C.L.humidity_management_cooldown_threshold_humidity_diff) - <
			|| (S.L._r8)
		(L.L.ac_humidity_management_active) (L.L.driver_ac_running) 1 = (L.L.passenger_ac_running) 1 = || (L.L._r8) && ||
		{if}
' no delay if humidity management or some other A/C-based function already active; activate (/ resume)
			0 s0
			-1 s1
			1 s2
		{else}
' start anew
			(L.L.ac_humidity_management_start_stop_delay) s1 -1 =
			{if}
				(C.L.ac_humidity_management_start_delay_additional_max) random
					(C.L.ac_humidity_management_start_delay_min) + s1
' increase delay based on current cabin humidity (or lack thereof)
				l7 (C.L.dehumidification_cabin_rel_humidity_min) >
				{if}
					(L.L.Cabinair_absHum) (C.L.ac_humidity_management_start_delay_env_factor) * l1 + s1
				{else}
					l3 (F.L.saturation_humidity_f_temp) (L.L.Cabinair_absHum) - 0 max
						(C.L.ac_humidity_management_start_delay_env_factor) * l1 + s1
				{endif}
			{endif}
' <_r9> = <Timegap>
			(L.L.ac_humidity_management_start_stop_timer) (L.L._r9) + s0 l1 > (L.L._r8) &&
			{if}
' actually activate
				0 s0
				-1 s1
				1 s2
			{else}
' no change; inactive and stays inactive
				0 s2
			{endif}
		{endif}
	{else}
' deactivation branch
		(L.L.ac_humidity_management_active)
		{if}
			(L.L.ac_humidity_management_start_stop_delay) s1 -1 =
			{if}
				(C.L.ac_humidity_management_stop_delay_additional_max) random (C.L.ac_humidity_management_stop_delay_min) + s1
			{endif}
' deactivation condition: either direct and _delayed_ (timer-based, when e.g. power is lost or all related functions
'  are switched off by user), or indirect and _instant_ (target cabin level of humidity achieved)
			(L.L.ac_humidity_management_start_stop_timer) (L.L._r9) + s0 l1 > l4 l5 && l7
				(C.L.dehumidification_cabin_rel_humidity_min) <= && l7
				(C.L.humidification_cabin_rel_humidity_max) >= && ||
			{if}
' actually deactivate
				0 s0 s2
				-1 s1
			{else}
' no change; active and stays active
				1 s2
			{endif}
		{else}
' no change; inactive and stays inactive
			0 s0 s2
			-1 s1
		{endif}
	{endif}
	l0 (S.L.ac_humidity_management_start_stop_timer)
	l1 (S.L.ac_humidity_management_start_stop_delay)
	l2 (S.L.ac_humidity_management_active)
{end}

' Determines the cabin heaters' output temperature.
'-----------------------------------------------------------------------------------------------------------------------
{macro:calculate_cabin_heater_temps}
	(L.L.has_passenger_ac) s7
	(L.L.cp_heizluefter_sw) (S.L._r8)
' <r3> = <Cabinair_Temp>
	l3 (C.L.cabin_heater_cabin_t_max) < (S.L._r11)  
' <r4> = <elec_busbar_main>
' <r5> = <engine_n> > <engine_n_min>
	l4 l5 && l7 (L.L._r8) && (L.L._r11) && l7 ! (L.L._r8) (L.L._r11) && (L.L.cp_taster_heat_or_frost) (L.L._r11) &&
		(L.L.Cabinair_relHum) (C.L.dehumidification_cabin_rel_humidity_min) > && || && || && (L.L.engine_temperature)
		(C.L.cabin_heater_engine_t_min) > &&
	{if}
		(L.L.engine_temperature) (C.L.heat_exchanger_effectivity) * s0
		1 s1
	{else}
		l3 s0
		0 s1
	{endif}
	l0 (S.L.cabin_heater_t_target)
	l1 (S.L.cabin_heaters_running_target)
' gradual update
	(M.L.actualize_cabin_heater_output_air_temp)
{end}

' Controls the cabin heaters' status. If the vehicle offers no passenger air-conditioning,
' <cp_taster_heat_or_frost> triggers the cabin heaters as well, in which case their operation is constrained both by
' maximum cabin temperature, as well as by minimum cabin humidity--whichever condition's complement gets satisfied
' first.
'-----------------------------------------------------------------------------------------------------------------------
{macro:actualize_cabin_heater_status}
	(L.L.has_passenger_ac) s7
	(L.L.cp_heizluefter_sw) (S.L._r8)
	(L.L.cp_taster_heat_or_frost) (S.L._r10)
	(L.L.cabin_heaters_running_target)
	{if}
' activation branch
		(L.L.cabin_heaters_running)
		{if}
' already active; resume
			0 s0
			-1 s1
			1 s2
		{else}
' start anew
			(L.L.cabin_heaters_start_stop_delay) s1 -1 =
			{if}
' increase delay based on engine temp
				(C.L.cabin_heater_start_delay_additional_max) random (C.L.cabin_heater_engine_t_normal)
					(L.L.engine_temperature) - 0 max (C.L.cabin_heater_start_delay_env_factor) * +
					(C.L.cabin_heater_start_delay_min) + s1
			{endif}
' <cabin_heater_cooldown_threshold_t_diff> and <humidity_management_cooldown_threshold_humidity_diff> contribute to
'  "anti-repeat" conditions, so as to prevent on-off loops
' <r3> = <Cabinair_Temp>
			l3 (C.L.cabin_heater_cabin_t_max) (C.L.cabin_heater_cooldown_threshold_t_diff) - < (S.L._r11)
			(L.L.Cabinair_relHum) (C.L.dehumidification_cabin_rel_humidity_min)
				(C.L.humidity_management_cooldown_threshold_humidity_diff) + > (S.L._r12)
' <_r9> = <Timegap>
			(L.L.cabin_heaters_start_stop_timer) (L.L._r9) + s0 l1 > l7 (L.L._r8) && (L.L._r11) && l7 ! (L.L._r8)
				(L.L._r11) && (L.L._r10) (L.L._r11) && (L.L._r12) && || && || &&
			{if}
' actually activate
				0 s0
				-1 s1
				1 s2
			{else}
' no change; inactive and stays inactive
				0 s2
			{endif}
		{endif}
	{else}
' deactivation branch
		(L.L.cabin_heaters_running)
		{if}
			(L.L.cabin_heaters_start_stop_delay) s1 -1 =
			{if}
				(C.L.cabin_heater_stop_delay_additional_max) random (C.L.cabin_heater_stop_delay_min) + s1
			{endif}
' deactivation condition: either direct and _delayed_ (timer-based, when e.g. power is lost or all relevant functions
'  are switched off by user), or indirect and _instant_ (target cabin temp and/or level of humidity achieved)
			l3 (C.L.cabin_heater_cabin_t_max) >= (S.L._r11)
			(L.L.Cabinair_relHum) (C.L.dehumidification_cabin_rel_humidity_min) <= (S.L._r12)
' <r4> = <elec_busbar_main>
' <r5> = <engine_n> > <engine_n_min>
			(L.L.cabin_heaters_start_stop_timer) (L.L._r9) + s0 l1 > l4 l5 && (L.L._r13) && l7 (L.L._r8) && (L.L._r11) &&
				l7 ! (L.L._r8) (L.L._r11) && (L.L._r10) (L.L._r11) (L.L._r12) || && || && || && ||
			{if}
' actually deactivate
				0 s0 s2
				-1 s1
			{else}
' no change; active and stays active
				1 s2
			{endif}
		{else}
' no change; inactive and stays inactive
			0 s0 s2
			-1 s1
		{endif}
	{endif}
	l0 (S.L.cabin_heaters_start_stop_timer)
	l1 (S.L.cabin_heaters_start_stop_delay)
	l2 (S.L.cabin_heaters_running)
' only relevant for <cp_taster_heat_or_frost_led> set in <actualize_panel_leds>; the later has to be able to distinguish
'  between temperature-constrained (<cp_heizluefter_sw> == 1) and temperature- _and_ humidity-constrained cabin heater
'  operation ((<cp_heizluefter_sw> == 0) && (<cp_taster_heat_or_frost> == 1)) in vehicles without passenger
'  air-conditioning, for aesthetics' sake.
	l2 l7 ! && (L.L._r10) && (L.L.Cabinair_relHum) (C.L.dehumidification_cabin_rel_humidity_min) > &&
		(S.L.cabin_heater_dehumidification_active)
{end}

' Controls the auxiliary heating's status.
'-----------------------------------------------------------------------------------------------------------------------
{macro:actualize_auxheat_status}
' <r4> = <elec_busbar_main>
	l4 (L.L.cp_taster_zusatzheizung) && (L.L.engine_temperature) (C.L.auxheat_engine_t_max) < &&
	{if}
' activation branch
		(L.L.auxheat_active)
		{if}
' already active; resume
			0 s0
			-1 s1
			1 s2
		{else}
' start anew
			(L.L.auxheat_start_stop_delay) s1 -1 =
			{if}
' increase delay based on engine temp
				(C.L.auxheat_start_delay_additional_max) random (C.L.auxheat_engine_t_normal)
					(L.L.engine_temperature) - 0 max (C.L.auxheat_start_delay_env_factor) * +
					(C.L.auxheat_start_delay_min) + s1
			{endif}
' <auxheat_cooldown_threshold_t_diff> contributes to an "anti-repeat" condition, so as to prevent on-off loops
' <_r9> = <Timegap>
			(L.L.auxheat_start_stop_timer) (L.L._r9) + s0 l1 > (L.L.engine_temperature) (C.L.auxheat_engine_t_max)
				(C.L.auxheat_cooldown_threshold_t_diff) - < &&
			{if}
' actually activate
				0 s0
				-1 s1
				1 s2
			{else}
' no change; inactive and stays inactive
				0 s2
			{endif}
		{endif}
	{else}
' deactivation branch
		(L.L.auxheat_active)
		{if}
			(L.L.auxheat_start_stop_delay) s1 -1 =
			{if}
				(C.L.auxheat_stop_delay_additional_max) random (C.L.auxheat_stop_delay_min) + s1
			{endif}
' deactivation condition: either direct and _delayed_ (timer-based, when e.g. power is lost or function is switched off
'  by user), or indirect and _instant_ (target engine temp achieved)
			(L.L.auxheat_start_stop_timer) (L.L._r9) + s0 l1 > l4 (L.L.engine_temperature) (C.L.auxheat_engine_t_max)
				>= && ||
			{if}
' actually deactivate
				0 s0 s2
				-1 s1
			{else}
' no change; active and stays active
				1 s2
			{endif}
		{else}
' no change; inactive and stays inactive
			0 s0 s2
			-1 s1
		{endif}
	{endif}
	l0 (S.L.auxheat_start_stop_timer)
	l1 (S.L.auxheat_start_stop_delay)
	l2 (S.L.auxheat_active)
{end}

' Computes the air volume inserted into the cabin by the driver's A/C.
'-----------------------------------------------------------------------------------------------------------------------
{macro:calculate_driver_ac_air_exchange_volumes}
	(C.L.cabinair_A_driver_ac) s7
	(L.L.cockpit_heizregler_geblaese) s0
' recirculation mode
	(L.L.cp_taster_frischumluft) s1 (L.L.cp_taster_fahrerklima) s2 ||
	{if}
		l1
		{if}
			(C.L.driver_ac_recirculation_mode_effectiveness) (S.L._r10)
		{else}
			(C.L.driver_ac_effectiveness) (S.L._r10)
		{endif}
' <r4> = <elec_busbar_main>
		l4
		{if}
' <r5> = <engine_n> > <engine_n_min>
			l5 !
			{if}
				l0 (C.L.driver_ac_engine_off_air_volume_factor) min s0	
			{else}
				l2
				{if}
					(L.L.driver_ac_running) s2 !
					{if}
						l0 (C.L.driver_ac_idle_air_volume_factor) min s0
					{else}
						l2 -1 =
						{if}
' A/C currently in the process of "pre-heating/-cooling"; no air flow permitted
							0 s0
						{endif}
					{endif}
				{endif}
			{endif}
			l7 l0 * (L.L._r10) * s0
		{else}
' no powerless air flow permitted in recirculation mode
			0 s0
		{endif}
		l0 s1
		{if}
' humidity equals the product of <r7>, <_r10>, unless recirculation and/or humidity management is active, in which
'  case it gets "magically" decreased to just a fraction thereof, to allow humidity management to cope
			l7 s1
			(L.L.cp_taster_frischumluft) (L.L.ac_humidity_management_active) ||
			{if}
				l1 (C.L.driver_ac_humidity_relevant_air_volume_recycling_factor) * s1
			{endif}
		{endif}
		l7 (L.L._r10) * (S.L._r8)
	{else}
' fresh-air mode
		l7 (L.L.velocity) 20 / abs (C.L.cabinair_windowdoor_minkmh) + (C.L.cabinair_windowdoor_effectivity) * 3.6 / *
			s7 (S.L._r8)
		l4
		{if}
			l5 !
			{if}
				l0 (C.L.driver_ac_engine_off_air_volume_factor) min s0
			{endif}
		{else}
			 0 s0
		{endif}
' humidity equal to temp-relevant air flow
		l0 (C.L.driver_ac_powerless_non_recirculated_air_volume_factor) max l7 * s0 s1
	{endif}
	l0 (S.L.cabinair_Vrate_driver_ac_target)
	l1 (S.L.cabinair_Vrate_driver_ac_humidity)
	(L.L._r8) (S.L.cabinair_Vrate_driver_ac_max)
' gradual update
	(M.L.actualize_driver_ac_temp_relevant_air_exchange_volume)
{end}

' Computes the air volume inserted into the cabin by the passengers' A/C.
'-----------------------------------------------------------------------------------------------------------------------
{macro:calculate_passenger_ac_air_exchange_volumes}
	(L.L.cp_taster_frischumluft)
	{if}
		(C.L.passenger_ac_recirculation_mode_effectiveness) s1
	{else}
		(C.L.passenger_ac_effectiveness) s1
	{endif}
	(C.L.cabinair_A_passenger_ac) s7
' <r4> = <elec_busbar_main>
	(L.L.has_passenger_ac) l4 &&
	{if}
		(L.L.passenger_ac_running) s2 0 >
		{if}
			1 s0
		{else}
			(L.L.cp_taster_klima)
			{if}
' <r5> = <engine_n> > <engine_n_min>
				l5
				{if}
					l2 !
					{if}
						(C.L.passenger_ac_idle_air_volume_factor) s0
					{else}
						l2 -1 =
						{if}
' A/C currently in the process of "pre-heating/-cooling"; no air flow permitted
							0 s0
						{endif}
					{endif}
				{else}
					(C.L.passenger_ac_engine_off_air_volume_factor) s0
				{endif}
			{else}
				0 s0
			{endif}
		{endif}
		l0
		{if}
			l0 * l1 * l7 * s0
		{endif}
	{else}
		0 s0
	{endif}
	l0 (S.L.cabinair_Vrate_passenger_ac_target)
	{if}
		l7 s0
' humidity equals the product of <r1>, <r7>, unless recirculation and/or humidity management is active, in which
'  case it gets "magically" decreased to just a fraction thereof, to allow humidity management to cope
		(L.L.cp_taster_frischumluft) (L.L.ac_humidity_management_active) ||
		{if}
			l0 (C.L.passenger_ac_humidity_relevant_air_volume_recycling_factor) * s0
		{endif}
	{endif}
	l0 (S.L.cabinair_Vrate_passenger_ac_humidity)
	l1 l7 * (S.L.cabinair_Vrate_passenger_ac_max)
' gradual update
	(M.L.actualize_passenger_ac_temp_relevant_air_exchange_volume)
{end}

' Computes the air volume heated up by the cabin heaters.
'-----------------------------------------------------------------------------------------------------------------------
{macro:calculate_cabin_heater_air_exchange_volume}
	(C.L.cabinair_A_cabin_heater) (L.L.cabin_heaters_running) * (C.L.number_of_cabin_heaters) * s7
	(L.L.auxheat_active) l6 (C.L.cabin_heater_turbo_mode_env_t_max) < (L.L.engine_temperature)
		(C.L.cabin_heater_turbo_mode_engine_t_max) < || &&
	{if}
		l7 (C.L.cabin_heater_turbo_mode_effectiveness_increase_factor) * s7
	{endif}
	l7 (C.L.cabin_heater_effectiveness) * (S.L.cabinair_Vrate_cabinheater_target)
	(C.L.cabinair_A_cabin_heater) (C.L.cabin_heater_turbo_mode_effectiveness_increase_factor) *
		(C.L.number_of_cabin_heaters) * (C.L.cabin_heater_effectiveness) * (S.L.cabinair_Vrate_cabinheater_max)
' gradual update
	(M.L.actualize_cabin_heater_air_exchange_volume)
{end}

' Simulates a greenhouse-like effect, premised on a maximum linear cabin temperature increase of
' ( <ghe_t_increase_rate_max> * <ghe_time_max> ) degrees centigrade,
' during a period of <ghe_time_max> seconds.
'
' Disclaimer: None of this is claimed to be scientifically sane, let alone correct.
'
' See also: Constants prefixed "ghe_" in <.\heizung_constfile_up.txt>.
'-----------------------------------------------------------------------------------------------------------------------
{macro:ghe_impact}
' time-of-day decrease factor; if zero, the next block doesn't matter, so just skip it
	(L.S.SunAlt) (F.L.ghe_severity_f_sun_elevation_angle) s2
	{if}
		l2
' time-of-year decrease factor
			(L.S.Month) (F.L.ghe_severity_f_season) *
' velocity decrease factor
			1 (L.L.velocity) abs (C.L.ghe_reduction_velocity_min) / 0 max (C.L.ghe_velocity_factor_max) min - *
' window / door state decrease factor
			1 (L.L.cabinair_A_windowdoor_open) (C.L.cabinair_A_windowdoor_max) / 0 max (C.L.ghe_windowdoor_factor_max)
			min - *
' precipitation decrease factor
			1 (L.L.PrecipRate) 0.5 / 0 max (C.L.ghe_precipitation_factor_max) min - *
' virtual A/C-induced decrease factor; otherwise the A/C would be unable to cope during day/summertime
			1 (L.L.driver_ac_running) 0 > (C.L.ghe_driver_ac_factor) * (L.L.passenger_ac_running) 0 >
			(C.L.ghe_passenger_ac_factor) * + (L.L.Cabinair_Temp) (C.L.ac_cooling_cabin_t_min) > * - *
' solar radiation / "brightness" decrease factor
' notes:
' - this is erroneous to some extent, because light sources _other_ than the sun (i.e., street lights) affect
'  <Envir_Brightness> as well
' - OMSI exposes neither the sun's "brightness" per se, nor the state of night-time light sources (<NightLightA> is
'  only made available to scenery objects)
' - the sole workaround would be to sample <Envir_Brightness> and/or calculate an average, perhaps additionally
'  sanitized by means of a  heuristic or two (e.g. "brightness factor must be proportionate to both sun's
'  elevation angle and precipitation rate ghe factors")
' - but it doesn't matter all that much and I'm currently not in the mood for such a level of detail
			(L.L.Envir_Brightness) *
' finally calculate the greenhouse-induced temperature increase rate:
' - the intended _maximum_ energy intake of the cabin equals
'  ( <stack-0> * <ghe_t_increase_rate_max> * <ghe_time_max> ),
' - but there are losses which must be balanced out, as the cabin would otherwise never heat up even close as much
'  (we want to _enforce_ the _maximum_ greenhouse effect severity, because that's what we empirically know)
' - only significant losses are taken into account here, namely heat loss due to a) the environment,
'  b) windows' and doors' state facilitating air flow, and c) A/C (in cooling mode);
'  other loss factors are disregarded for simplicity's sake
' - from a scientific standpoint this is probably all nonsense, as the energy rate is constant
			(C.L.ghe_t_increase_rate_max) * s0 s1
		{if}
' current frame losses (1)
			(L.L.cabinair_Qrate_envir) (C.L.cabinair_cvm) / /-/ (L.L.cabinair_Qrate_windowdoor) +
				(L.L.cabinair_Qrate_driver_ac) + s1
' max permissible losses per frame after <ghe_time_max> (2)
			l0 (L.L.ghe_env_resistance_const) * l0 (L.L.ghe_windowdoor_resistance_const) *
				(L.L.cabinair_Vrate_windowdoor) * + l0 (L.L.ghe_ac_resistance_const) *
				(L.L.cabinair_Vrate_driver_ac) * + s2
			(L.L.has_passenger_ac)
			{if}
				l1 (L.L.cabinair_Qrate_passenger_ac) + s1
				l2 l0 (L.L.ghe_ac_resistance_const) * (L.L.cabinair_Vrate_passenger_ac) * + s2
			{endif}
' have ( (1) + <r0> ) increase towards (2) but not exceed it, to prevent indefinite cabin temperature increase
			l1 0 min abs l0 + l2 min s1
		{endif}
	{else}
		0 s0 s1
	{endif}
	l0 (S.L.cabinair_Qrate_ghe)
	l1 (S.L.cabinair_Qrate_ghe_plus_losses)
{end}

' Computes the degree of cabin window misting on the interior side. Cabin windows mist on the inside when the cabin is
' sufficiently humid, and the environment is sufficiently cold--colder than the dew point of the cabin, specifically.
'-----------------------------------------------------------------------------------------------------------------------
{macro:calculate_cabin_window_int_misting_degree}
' <r0> = <Cabinair_Temp>
' <_r8> = <Cabinair_relHum>
	l0 (S.L._r10) (L.L._r8) (S.L._r9) (M.L.calculate_cabin_window_misting_degree)
	(L.L._r11) (S.L.cabin_window_int_misting_target)
	(L.L._r13) (S.L.cabin_dew_point)
' gradual update
	(M.L.actualize_cabin_window_int_misting_degree)
{end}

' Computes the degree of cabin window misting on the exterior side. Cabin windows mist on the outside when the
' environment is sufficiently humid, and the cabin is sufficiently cold--colder than the dew point of the
' environment, specifically.
'-----------------------------------------------------------------------------------------------------------------------
{macro:calculate_cabin_window_ext_misting_degree}
' compute relative env humidity first (OMSI already knows this, but keeps it a secret)
' <r6> = <Weather_Temperature>
' <r7> = <Weather_AbsHum>
	l7 l6 (S.L._r10) (F.L.saturation_humidity_f_temp) / (S.L.env_rel_humidity) (S.L._r9)
		(M.L.calculate_cabin_window_misting_degree)
	(L.L._r11) (S.L.cabin_window_ext_misting_target)
	(L.L._r13) (S.L.env_dew_point)
' gradual update
	(M.L.actualize_cabin_window_ext_misting_degree)
{end}

'----------------------------------------------
'    <calculate_driver_ac_temps> delegates
'----------------------------------------------

' Gradually in-/de-crements <driver_ac_t> by <ac_t_out_xxx_update_rate> (depending on whether the A/C is
' currently starting up normally, or is in eco mode or shutting down), until it reaches
' <driver_ac_t_target>.
'-----------------------------------------------------------------------------------------------------------------------
{macro:actualize_driver_ac_output_air_temp}
' slow start-up - fast shut-down; fast rate applies to eco mode in either case
	(L.L.driver_ac_running) abs 1 =
	{if}
		(C.L.ac_t_out_slow_update_rate) s7
	{else}
		(C.L.ac_t_out_fast_update_rate) s7
	{endif}
	(L.L.driver_ac_t) (S.L._r10) (L.L.driver_ac_t_target) (S.L._r11) l7 (S.L._r12) (M.L.from_r10_to_r11_at_r12)
		(L.L._r10) (S.L.driver_ac_t)
{end}

'-------------------------------------------------
'    <calculate_passenger_ac_temps> delegates
'-------------------------------------------------

' Gradually in-/de-crements <passenger_ac_t> by <ac_t_out_xxx_update_rate> (depending on whether the A/C is
' currently starting up normally, or is in eco mode or shutting down), until it reaches
' <passenger_ac_t_target>.
'-----------------------------------------------------------------------------------------------------------------------
{macro:actualize_passenger_ac_output_air_temp}
' slow start-up - fast shut-down; fast rate applies to eco mode in either case
	(L.L.passenger_ac_running) abs 1 =
	{if}
		(C.L.ac_t_out_slow_update_rate) s7
	{else}
		(C.L.ac_t_out_fast_update_rate) s7
	{endif}
	(L.L.passenger_ac_t) (S.L._r10) (L.L.passenger_ac_t_target) (S.L._r11) l7 (S.L._r12) (M.L.from_r10_to_r11_at_r12)
		(L.L._r10) (S.L.passenger_ac_t)
{end}

'-------------------------------------------------
'    <calculate_cabin_heater_temps> delegates
'-------------------------------------------------

' Gradually in-/de-crements <cabin_heater_t> by cabin_heater_t_out_xxx_update_rate> (depending on whether the cabin
' heaters are currently starting up or stopping), until it reaches <cabin_heater_t_target>.
'-----------------------------------------------------------------------------------------------------------------------
{macro:actualize_cabin_heater_output_air_temp}
' fast start-up - slow shut-down
	(L.L.cabin_heaters_running)
	{if}
		(C.L.cabin_heater_t_out_fast_update_rate) s7
	{else}
		(C.L.cabin_heater_t_out_slow_update_rate) s7
	{endif}
	(L.L.cabin_heater_t) (S.L._r10) (L.L.cabin_heater_t_target) (S.L._r11) l7 (S.L._r12) (M.L.from_r10_to_r11_at_r12)
		(L.L._r10) (S.L.cabin_heater_t)
{end}

'-------------------------------------------------------------
'    <calculate_driver_ac_air_exchange_volumes> delegates
'-------------------------------------------------------------

' Gradually in-/de-crements <cabinair_Vrate_driver_ac> by <driver_ac_temp_relevant_air_volume_update_rate>, until it
' reaches <cabinair_Vrate_driver_ac_target>.
'-----------------------------------------------------------------------------------------------------------------------
{macro:actualize_driver_ac_temp_relevant_air_exchange_volume}
	(L.L.cabinair_Vrate_driver_ac) (S.L._r10) (L.L.cabinair_Vrate_driver_ac_target) (S.L._r11)
		(C.L.driver_ac_temp_relevant_air_volume_update_rate) (S.L._r12)
		(M.L.from_r10_to_r11_at_r12) (L.L._r10)
		(S.L.cabinair_Vrate_driver_ac)
{end}

'----------------------------------------------------------------
'    <calculate_passenger_ac_air_exchange_volumes> delegates
'----------------------------------------------------------------

' Gradually in-/de-crements <cabinair_Vrate_passenger_ac> by <passenger_ac_temp_relevant_air_volume_update_rate>, until
' it reaches <cabinair_Vrate_passenger_ac_target>.
'-----------------------------------------------------------------------------------------------------------------------
{macro:actualize_passenger_ac_temp_relevant_air_exchange_volume}
	(L.L.cabinair_Vrate_passenger_ac) (S.L._r10) (L.L.cabinair_Vrate_passenger_ac_target) (S.L._r11)
		(C.L.passenger_ac_temp_relevant_air_volume_update_rate) (S.L._r12)
		(M.L.from_r10_to_r11_at_r12) (L.L._r10)
		(S.L.cabinair_Vrate_passenger_ac)
{end}

'---------------------------------------------------------------
'    <calculate_cabin_heater_air_exchange_volume> delegates
'---------------------------------------------------------------

' Gradually in-/de-crements <cabinair_Vrate_cabinheater> by <cabin_heater_air_volume_xxx_update_rate> (depending on
' whether the cabin heaters are currently starting up or stopping), until it reaches
' <cabinair_Vrate_cabinheater_target>.
'-----------------------------------------------------------------------------------------------------------------------
{macro:actualize_cabin_heater_air_exchange_volume}
' fast start-up - slow shut-down
	(L.L.cabin_heaters_running)
	{if}
		(C.L.cabin_heater_air_volume_fast_update_rate) s7
	{else}
		(C.L.cabin_heater_air_volume_slow_update_rate) s7
	{endif}
	(L.L.cabinair_Vrate_cabinheater) (S.L._r10) (L.L.cabinair_Vrate_cabinheater_target) (S.L._r11) l7 (S.L._r12)
		(M.L.from_r10_to_r11_at_r12) (L.L._r10) (S.L.cabinair_Vrate_cabinheater)
{end}

'--------------------------------------------------------------
'    <calculate_cabin_window_int_misting_degree> delegates
'--------------------------------------------------------------

' Gradually in-/de-crements <cabin_window_int_misting> by <cabin_window_misting_update_rate>, until it reaches
' <cabin_window_int_misting_target>.
'-----------------------------------------------------------------------------------------------------------------------
{macro:actualize_cabin_window_int_misting_degree}
	(L.L.cabin_window_int_misting) (S.L._r10) (L.L.cabin_window_int_misting_target) (S.L._r11)
		(C.L.cabin_window_misting_update_rate) (S.L._r12) (M.L.from_r10_to_r11_at_r12)
		(L.L._r10) (S.L.cabin_window_int_misting)
{end}

'--------------------------------------------------------------
'    <calculate_cabin_window_ext_misting_degree> delegates
'--------------------------------------------------------------

' Gradually in-/de-crement <cabin_window_ext_misting> by <cabin_window_misting_update_rate>, until it reaches
' <cabin_window_ext_misting_target>.
'-----------------------------------------------------------------------------------------------------------------------
{macro:actualize_cabin_window_ext_misting_degree}
	(L.L.cabin_window_ext_misting) (S.L._r10) (L.L.cabin_window_ext_misting_target) (S.L._r11)
		(C.L.cabin_window_misting_update_rate) (S.L._r12) (M.L.from_r10_to_r11_at_r12)
		(L.L._r10) (S.L.cabin_window_ext_misting)
{end}

'--------------------------------------
'     shared delegates / utilities
'--------------------------------------

' Delegated to from <calculate_xxx_ac_temps> to check whether air-conditioning _can_ currently be activated. The value
' "returned" (as <_r8>) by this macro is true iff the environmental temperature is within reasonable bounds--such that
' the coolant would not solidify or evaporate--and the current cabin temperature is below or above the "ideal" cabin
' temperature range (expressed by the <ac_cooling_cabin_t_xxx> constants).
'-----------------------------------------------------------------------------------------------------------------------
{macro:ac_available}
' <r0> = non-final, i.e., ideal, value of <driver_ac_t_target> or <passenger_ac_t_target>, if air-conditioning actually
'  gets activated (in non-eco mode); the final value will in practice be lower or higher than that, when heating or
'  cooling, respectively
' <r3> = <Cabinair_Temp>
' <r6> = <Weather_Temperature>
	l6 (C.L.ac_env_t_min) > l6 (C.L.ac_env_t_max) < && l3 (C.L.ac_heating_cabin_t_max) < l0 l3 > &&
' as part of the cooling preconditions, we additionally have to ensure that the cabin heaters are _not_ the source of
'  the "excess" heat (i.e., causing <r3> to exceed <ac_cooling_cabin_t_min>), as cooling would otherwise be pointless
		l3 (C.L.ac_cooling_cabin_t_min) > l0 l3 < && (L.L.cabin_heaters_running) ! && (L.L.cabinair_Vrate_cabinheater)
		! && (L.L.cp_heizluefter_sw) ! && (L.L.has_passenger_ac) (L.L.has_passenger_ac) !
		(L.L.cp_taster_heat_or_frost) ! && || && || && (S.L._r8)
{end}

' Delegated to from <calculate_xxx_ac_temps> after <ac_available> has yielded true, i.e., when air-conditioning is to
' be activated, to determine whether the economy-like heating or cooling mode is applicable (also known as "free"
' heating / cooling). This is the case when the cabin needs to be either _heated_ and the environment is
' sufficiently _warmer_ than the former already, or when the former needs to be _cooled_ and the later
' happens to be _cooler_ than the former. If so, fresh air is used as the coolant agent. Practically
' speaking, this mode is equivalent to the A/C being off and fresh air being directly "pumped" into
' the cabin; unlike the later case, however, temperature and humidity constraints are still
' enforced while in eco mode. The outcome is "returned" to the delegating macro via <_r8>.
'-----------------------------------------------------------------------------------------------------------------------
{macro:ac_eco_mode_available}
' <r0> = non-final, i.e., ideal, value of <driver_ac_t_target> or <passenger_ac_t_target>, if air-conditioning actually
'  gets activated (in non-eco mode); the final value will in practice be lower or higher than that, when heating or
'  cooling, respectively
' <r3> = <Cabinair_Temp>
' <r6> = <Weather_Temperature>
' about these constants:
' - <ac_eco_mode_xxx_env_t_target_t_diff_max> (C1) indicates how much cooler (when heating is desired) or warmer (when
'  cooling is desired) than <r0>, <r6> must _at most_ be
' - <ac_eco_mode_xxx_env_t_cabin_t_diff_min> (C2) indicates how much cooler (when cooling is desired) or warmer (when
'  heating is desired) than <r3>, <r6> must _at least_ be
' eco-heating-precondition:
'  <r6> > <r0> - C1
'  <r3> < <r6> - C2
' eco-cooling precondition:
'  <r6> < <r0> + C1
'  <r3> > <r6> + C2
' note that C2 must be sufficiently high in the cooling case, or the cooling effect is going to be very weak, thus
'  easily "overpowered" by the engine and greenhouse losses
	(L.L.cp_taster_frischumluft) ! l0 l3 > l6 l0 (C.L.ac_eco_mode_heating_env_t_target_t_diff_max) - > && l3 l6
		(C.L.ac_eco_mode_heating_env_t_cabin_t_diff_min) - < &&	l0 l3 < l6 l0
		(C.L.ac_eco_mode_cooling_env_t_target_t_diff_max) + < && l3 l6
		(C.L.ac_eco_mode_cooling_env_t_cabin_t_diff_min) + > && || &&
		(S.L._r8)
{end}

' Delegated to from <actualize_xxx_ac_status> to determine, when <xxx_ac_running> is to be set to 1, if <xxx_ac_t> is
' "close enough"--as per the <ac_xxx_output_t_to_t_target_diff_max> constants--to <xxx_ac_t_preview>
' (<xxx_ac_t_target>, eventually) in order to be considered "comfortable".
'
' As an example, say that the cabin is to be cooled down from an initial temperature of 40 oC. The A/C, i.e., <calculate_xxx_ac_temps>,
' will start gradually decrementing <xxx_ac_t> towards <xxx_ac_t_target>. At first, however, <xxx_ac_t>, being of, say, 39.5 oC, even
' if indeed "capable of" cooling the cabin, would still perceived as uncomfortably high by humans. Thus, through this macro, the A/C
' is given some extra time to cool down (or heat up) adequately before actually inserting any air into the cabin. While in this
' intermediate state, the A/C's corresponding <xxx_ac_running> variable is set to -1.
'-----------------------------------------------------------------------------------------------------------------------
{macro:ac_t_comfortable}
' the following does _not_ apply to eco mode
' <r2> = <xxx_ac_t_running> (actual assignment takes place in the delegating macro, once this one has returned)
	l2 1 =
	{if}
' <r0> = <xxx_ac_t>
' <r1> = <xxx_ac_t_preview> (used instead of <xxx_ac_t_target> because <calculate_xxx_ac_temps> might not yet have had
'  a chance to set the later)
' <r3> = <Cabinair_Temp>
		l1 l0 - abs s0
		l3 (C.L.ac_heating_cabin_t_max) < l0 (C.L.ac_heating_output_t_to_t_target_diff_max) >= && l3
			(C.L.ac_cooling_cabin_t_min) > l0 (C.L.ac_cooling_output_t_to_t_target_diff_max) >= &&
			||
		{if}
			-1 s2
		{endif}
	{endif}
{end}

' Increments or decrements the value having been assigned to <_r10> at a constant rate of <_r12> / frame, until
' <_r10> = <_r11>.
'-----------------------------------------------------------------------------------------------------------------------
{macro:from_r10_to_r11_at_r12}
	(L.L._r10) (L.L._r11) = !
	{if}
		(L.L._r11) (L.L._r10) - sgn (S.L._r13) (L.L._r12) (L.S.Timegap) * * (L.L._r10) + (S.L._r10) (L.L._r11) >=
			(L.L._r13) 1 = && (L.L._r10) (L.L._r11) <= (L.L._r13) -1 = && ||
		{if}
			(L.L._r11) (S.L._r10)
		{endif}
	{endif}
{end}

' Triggers a sound when one of the heating / cooling panel's buttons gets pushed / released.
'-----------------------------------------------------------------------------------------------------------------------
{macro:button_sound}
' <_r15> = temporarily-saved button state
	(L.L._r15)
	{if}
		(T.L.ev_VDV_toggle_on)
	{else}
		(T.L.ev_VDV_toggle_off)
	{endif}
{end}

' Delegated to from <calculate_cabin_window_xxx_misting_degree> to compute the degree of cabin window (interior or
' exterior, accordingly) fogging.
'
' The macro initially checks whether there's enough humidity to begin with, by probing the relative (cabin or
' environmental) humidity value stored in <_r9>. It proceeds by estimating the minimum and, subsequently,
' actual dew point (which, despite being known to OMSI, is not exposed by it, and thus needs to be
' recalculated), given the (cabin or environmental) temperature stored in <_r10> and relative
' humidity. Lastly, it determines if <_r10>'s proximity to the dew point is small enough for
' condensation to occur. The macro's outputs--dew point and misting degree--are persisted in
' <_r13> and <_r11>, respectively.
'
' Note to modders / integrators intending to actually use these hooks: You might wish to additionally consider checking
' whether it is currently raining / snowing, and, if so, zero-out <_r11>, as you will otherwise end up having two
' textures--fog _and_ rain / snow--displayed on your windows at the same time, which might not be that
' aesthetically pleasing (unless your rain / snow rendering mechanism is inherently dynamic, of
' course).
'-----------------------------------------------------------------------------------------------------------------------
{macro:calculate_cabin_window_misting_degree}
	(L.L._r9) (C.L.cabin_window_misting_rel_humidity_min) (S.L._r11) - 0 max 1 (L.L._r11) - / (L.L._r10) d
		(F.L.dew_point_min_f_temp) (S.L._r13) - (L.L._r9) (F.L.dew_point_diff_f_rel_humidity) * (L.L._r13)
		+ (L.L._r10) min d (S.L._r13) (C.L.cabin_window_misting_dew_point_threshold) +
		(C.L.cabin_window_misting_dew_point_error_tolerance) + < * 1 min (S.L._r11)
{end}
